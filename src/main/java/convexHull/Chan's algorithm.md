Алгоритм Джарвиса
---

По-другому "Gift wrapping algorithm" (Заворачивание подарка). 
Он заключается в том, что мы ищем выпуклую оболочку последовательно, 
против часовой стрелки, начиная с определенной точки.

Описание алгоритма
---
Выберем какую-нибудь точку p0, которая гарантированно попадет в выпуклую оболочку. Например, нижнюю, а если таких несколько, то самую левую из них.

Дальше будем действовать так: найдем самую "правую" точку от последней добавленной (то есть точку с минимальным полярным углом относительно нее) 
и добавляем ее в оболочку. Будем так итеративно добавлять точки, пока не "замкнемся", 
то есть пока самой правой точкой не станет p0.

Корректность
---

Корректность алгоритма легко доказывается по индукции

- На нулевом шаге мы выбрали точку, точно лежащую в выпуклой оболочке.
- На i-м шаге мы взяли такую точку, что все остальные лежат по левую сторону отрезка (p<sub>i - 1</sub>, p<sub>i</sub>),
и поэтому точно не перекрывают точку p<sub>i</sub> 

Сложность
---

Добавление каждой точки в ответ занимает `O(n)` времени, всего точек будет `k`, поэтому итоговая сложность `O(nk)`. 
В худшем случае, когда оболочка состоит из всех точек сложность `O(n ^ 2)`


Алгоритм Грэхэма
---

Алгоритм Грэхэма - это оптимизация алгоритма Джарвиса,
основанная на следующем наблюдении: если отсортировать все точки по полярному углу относительно точки p<sub>0</sub>,
то выпуклая оболочка будет какой-то подпоследовательностью такого отсортированного массива точек.

Алгоритм последовательно строит выпуклые оболочки для каждого префикса этого отсортированного массива. 
Можно заметить, что при добавлении i-й точки в оболочку нужно лишь удалить сколько-то последних добавленных точек, 
которые не будут входить в новую оболочку, а именно тех, которые "покрываются" новой точкой и своей предыдущей.

Описание алгоритма
---
1. Находим точку p<sub>0</sub> нашего множества с самой маленькой y - координатой (если таких несколько, берем самую левую из них), добавляем в ответ
2. Сортируем все остальные точки по полярному углу относительно p<sub>0</sub>
3. Добавляем в ответ p<sub>1</sub> - саму первую из отсортированных точек.
4. Берем следующую по счету точку t. Пока t и две последних точки в текущей оболочке p<sub>i</sub> и p<sub>i - 1</sub> образуют неправый поворот (вектора p<sub>i</sub> t и p<sub>i−1</sub>p<sub>i</sub>), удаляем из оболочки p<sub>i</sub>
5. Добавляем в оболочку t
6. Делаем п.4, пока не закончатся точки.

Чтобы проводить это удаление эффективно, мы можем хранить выпуклую оболочку в стеке и в цикле `while` 
смотреть на три последние точки и проверять, образуют ли они правый поворот. Если это так, то среднюю следует удалить - мы нашли треугольник (p<sub>0</sub>, p<sub>i</sub>, p<sub>i - 2</sub>), который содержит p<sub>i - 1</sub>, а значит ее можно удалить. 


Сложность
---

Каждая точка будет добавлена один раз удалена не более одного раза, что занимает константное количество операций. 
Соответственно, время работы будет упираться во время работы сортировки, то есть `O(n logn)`


Алгоритм Чана
---

Является комбинацией двух алгоритмов - Джарвиса и Грэхэма. Недостатком Грэхэма является необходимость сортировки всех точек по полярному углу, что занимает достаточно много времени `O(nlogn)`. Джарвис требует перебора всех точек для каждой из `k` точек оболочки, что в худшем случае занимает `O(n ^ 2)`

Описание алгоритма
---

1. Разобьем все множество на произвольные группы по m штук в каждой. Будем считать, что `m` нам известно. Тогда всего групп окажется `r = n / m`
2. Для каждой группы запускаем Грэхэма
3. Начиная с самой нижней точки ищем самую выпуклую оболочку Джарвисом, но перебирая не все точки, а по одной из каждой группы.


Сложность 
---
На втором шаге алгоритма в каждой группе оболочка ищется за `O(m logm)`, общее время - `O(rm logm) = O(n logm)`. На третьем шаге поиск каждой следующей точки в каждой группе занимает `O(logm)`, так как точки уже отсортированы, и мы можем найти нужную бинарным поиском. Тогда  поиск по всем группам займет `O(rlogm) = O(n / m logm)`. Всего таких шагов будет k, значит общее время - `O(kn / m logm)`. Итоговое время - `O(n(1 + k/m)logm)`. Несложно видеть, что минимум достигается при m = k. В таком случае сложность равна `O(n logk)`

	